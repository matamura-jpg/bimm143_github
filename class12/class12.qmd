---
title: "Class 12: RNASeq Analysis"
author: "Mai Tamura (PID: A18594079)"
format: pdf
toc: true
---

## Background

Today we will analyze some RNASeq data from Himes et al. on the effects of a common steroid (dexamethasone) on airway smooth muscle cells (ASM cells).

Are starting point i the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without drug).

## Data import

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

```{r}
head(metadata)
```

> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> How many different experiments are in the dataset?

```{r}
ncol(counts)
```

```{r}
ncol(metadata)
```

> Q2. How many ‘control’ cell lines do we have? 

```{r}
sum(metadata$dex == "control")
```

## Toy differential gene expression

To start our analysis, let's calculate the mean for all genes in the "control" experiments.

1. Extract all "control" columns from the `counts` object.
2. Calculate the mean for all rows (i.e. genes) of these "control" columns.

3-4. Do the same for "treated".
5. Compare these `control.mean` and ` treated.mean` values.

```{r}
control.inds <- metadata$dex == "control"
control.counts <- counts[ , control.inds]
head(control.counts)
```

```{r}
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 

```{r}
control.mean <- rowMeans(control.counts)
head(control.mean)
```

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[ , treated.inds]
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```

Store together for ease of bookkeeping as `meancounts`.

```{r}
meancounts <- data.frame(control.mean, treated.mean)
head(meancounts)
```

Make a plot of control vs treated. 

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples.

```{r}
plot(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

```{r}
library(ggplot2)

ggplot(meancounts, aes(control.mean, treated.mean)) +
  geom_point(alpha=0.4, size=2, shape=16) 
```

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

```{r}
plot(meancounts, log="xy")
```

Let's calculate the log2 fold change for our treated over control mean counts.

```{r}
meancounts$log2fc <-
log2(meancounts$treated.mean /
  meancounts$control.mean)
```

```{r}
head(meancounts)
```

A common "rule of thumb" is a log2 fold change cutoff of +2 and -2 to call genes "Up regulated" or "Down regulated".

Number of "up" genes at +2 threshold

```{r}
sum(meancounts$log2fc >= +2, na.rm=T)
```

Number of "down" genes at -2 threshold

```{r}
sum(meancounts$log2fc <= -2, na.rm=T)
```

Let’s filter our data to remove genes with zero expression.

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)
head(zero.vals)
```

```{r}
mycounts <- meancounts[-unique(zero.vals[,1]),]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The `arr.ind = TRUE` causes `which()` to return both the row and column indices (positions) where the condition is TRUE, instead of just the linear indices. The `unique()` returns only the distinct elements from its input, removing any duplicates.

> Q8. Can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(mycounts$log2fc > +2, na.rm=T)
```

> Q9. Can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(mycounts$log2fc < -2, na.rm=T)
```

> Q10. Do you trust these results? Why or why not?

No, these results are not fully trustworthy since fold change does not show statistically significance and are likely to be very misleading.


## DESeq2 analysis

Let's do this analysis properly and keep our inner stats happy - i.e. are the differences we see between drug and no drug significant given the replicate experiments.

```{r, message=FALSE}
library(DESeq2)
```

For DESeq analysis, we need three things.

- count values (`countData`)
- metadata telling us about the columns in `contData` (`colData`)
- design of the experiment (i.e. what do you want to compare)

Our first function from DESeq2 will setup the input required for analysis by storing these 3 things together.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~dex)
```

The main function in DESeq that runs the analysis is called `DESeq()`.

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

## Volcano plot

This is common summary figure from these types of experiments and plot the log2 fold-change vs the adjusted p-value.

```{r}
plot(res$log2FoldChange, res$padj)
```

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col="red")
```

```{r}
log(0.4)
log(0.04)
```

## Save our results

```{r}
write.csv(res, file="my_results.csv")
```


## Add gene annotation

To help make sense of our results an communicate them to other folks we need to add some more annotation to our main `res` object.

We will use two bioconductor packages to first map IDs to different formats including the classic gene "symbol" gene name.

I will install these with the following commands.
`BicManager::install("AnnotationDbi")`
`BicManager::install("org.Hs.eg.db")`

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in `org.Hs.eg.db`
```{r}
columns(org.Hs.eg.db)
```

We can translate or "map" IDs between any of these 26 databases using the `mapIds()` function.

```{r}
res$symbol <- mapIds(keys = row.names(res), # our current IDs
                     keytype = "ENSEMBL",   # the format of our IDs
                     x = org.Hs.eg.db,      # where to get the mappings from
                     column = "SYMBOL")     # the format/DB to map to

head(res)
```

Add the mappings for "GENENAME" and "ENTREZID" and store as `res$genename` and `res$entrez`

```{r}
res$genename <- mapIds(keys = row.names(res), # our current IDs
                       keytype = "ENSEMBL",   # the format of our IDs
                       x = org.Hs.eg.db,      # where to get the mappings from
                       column = "GENENAME")   # the format/DB to map to

res$entrez <- mapIds(keys = row.names(res), # our current IDs
                     keytype = "ENSEMBL",   # the format of our IDs
                     x = org.Hs.eg.db,      # where to get the mappings from
                     column = "ENTREZID")   # the format/DB to map to

head(res)
```

## Pathway analysis

There are lots of bioconductor packages to do this type of analysis. For now let's just try one called **gage** again we need to install this if we don't have it already.

```{r, message=FALSE}
library(gage)
library(gageData)
library(pathview)
```

To use **gage** I need to two things

- a named vector of DEGs (our geneset of interest)
- a set of pathways or datasets to use for annotation

```{r}
x <- c("barry"=5, "lisa"=10)
x
```

```{r}
names(x) <- c("low", "high")
x
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrez
head(foldchanges)
```

```{r}
data(kegg.sets.hs)

keggres = gage(foldchanges, gsets = kegg.sets.hs)
```

In our results object we have:
```{r}
attributes(keggres)
```

```{r}
head(keggres$less, 5)
```

Let's look at one of these pathways with our genes colored up so we can see the overlap

```{r}
pathview(pathway.id = "hsa05310", gene.data = foldchanges)
```

Add this pathway figure to our lab report

![](hsa05310.pathview.png)

## Save our main results

```{r}
write.csv(res, file="myresults_annotated.csv")
```




